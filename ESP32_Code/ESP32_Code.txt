// Required Libraries:
// 1. "ArduinoWebSockets" by Markus Sattler
// 2. "OneWire" by Paul Stoffregen
// 3. "DallasTemperature" by Miles Burton
#include <WebSocketsClient.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include "esp_camera.h"
#include "WiFi.h"
#include "secrets.h"

// #define CAMERA_MODEL_XIAO_ESP32S3
#define CAMERA_MODEL_AI_THINKER
#include "camera_pins.h"

// --- Dallas Temperature Sensor ---
#define ONE_WIRE_BUS 2 // The GPIO pin for the DS18B20 sensor
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);
float dallasTempC = -127.0; // Global variable for the sensor reading

// --- Global Variables ---
WebSocketsClient webSocket;
uint32_t frameId = 0;

// --- Status Update Variables ---
const int statusInterval = 30000; // Send status every 5 seconds
unsigned long previousStatusMillis = 0;
size_t lastFrameSize = 0;
long lastFrameTime = 0;
static unsigned long minCaptureTime = ULONG_MAX;
static unsigned long maxCaptureTime = 0;

// --- ESP32 Internal Temperature Sensor Declaration ---
#ifdef CAMERA_MODEL_AI_THINKER
extern "C" uint8_t temprature_sens_read();
#endif

// Forward declarations
void sendStatusUpdate();
void webSocketEvent(WStype_t type, uint8_t * payload, size_t length);
bool isValidJPEG(const uint8_t* buf, size_t len);

// --- Task function to handle camera and WebSockets, pinned to Core 1 ---
void camera_and_ws_task(void *pvParameters) {
  for (;;) { // Infinite loop for the task

    webSocket.loop();

    if (!webSocket.isConnected()) {
      delay(500);
      continue;
    }

    long frameStartTime = millis();

    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) {
      Serial.println("Camera capture failed");
      delay(100);
      continue;
    }

    if (isValidJPEG(fb->buf, fb->len)) {
      const char* header = "IMG:";
      size_t headerLen = strlen(header);
      size_t totalLen = headerLen + fb->len;

      uint8_t* wrappedBuf = (uint8_t*)malloc(totalLen);
      if (wrappedBuf) {
        memcpy(wrappedBuf, header, headerLen);
        memcpy(wrappedBuf + headerLen, fb->buf, fb->len);

        if (webSocket.sendBIN(wrappedBuf, totalLen)) {
          lastFrameSize = fb->len;
          lastFrameTime = millis() - frameStartTime;
          if (lastFrameTime < minCaptureTime) minCaptureTime = lastFrameTime;
          if (lastFrameTime > maxCaptureTime) maxCaptureTime = lastFrameTime;
          Serial.printf("FB Addr: %p | Size: %u | Time: %ld ms\n", fb->buf, fb->len, lastFrameTime);
          Serial.printf("RSSI: %ld dBm | Heap: %u | PSRAM: %u\n", WiFi.RSSI(), ESP.getFreeHeap(), ESP.getFreePsram());
          frameId++;
        } else {
          Serial.println("Error sending frame via WebSocket");
        }

        free(wrappedBuf);
      } else {
        Serial.println("Failed to allocate buffer for image");
      }
    } else {
      Serial.println("Invalid JPEG frame, not sending");
    }

    esp_camera_fb_return(fb);

    if (millis() - previousStatusMillis > statusInterval) {
      previousStatusMillis = millis();

      sendStatusUpdate();
    }
  }
}

void setup() {
    Serial.begin(115200);
    Serial.setDebugOutput(true);
    Serial.println();

    // --- Camera Initialization ---
    camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM;
    config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM;
    config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM;
    config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM;
    config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM;
    config.pin_href = HREF_GPIO_NUM;
    config.pin_sccb_sda = SIOD_GPIO_NUM;
    config.pin_sccb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = PWDN_GPIO_NUM;
    config.pin_reset = RESET_GPIO_NUM;
    config.xclk_freq_hz = 20000000;
    config.pixel_format = PIXFORMAT_JPEG;
    config.frame_size = FRAMESIZE_SXGA;
    config.jpeg_quality = 10;
    config.fb_count = 2;
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.grab_mode = CAMERA_GRAB_LATEST;

    esp_err_t err = esp_camera_init(&config);
    if (err != ESP_OK) {
        Serial.printf("Camera init failed with error 0x%x", err);
        return;
    }
    sensor_t *s = esp_camera_sensor_get();
    if (s != nullptr) {
        s->set_vflip(s, 1); // 1 = enable vertical flip, 0 = disable
        Serial.println("Vertical flip enabled.");
    }

    Serial.println("Camera initialized.");
    
    // --- Dallas Sensor Setup ---
    sensors.begin();
    sensors.requestTemperatures(); // Request the first temperature reading
    Serial.println("Initial temperature request sent to DS18B20.");

    // --- WiFi Connection ---
    WiFi.begin(WIFI_SSID, WIFI_PASS);
    Serial.print("Connecting to WiFi");
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
    }
    Serial.println("\nWiFi connected!");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());

    int rssi = WiFi.RSSI(); 
    Serial.println(String(rssi));

    // --- WebSocket Client Setup ---
    webSocket.begin(WEBSOCKET_SERVER, WEBSOCKET_PORT);
    webSocket.onEvent(webSocketEvent);
    webSocket.setReconnectInterval(5000);
    
    // --- Start Camera Task ---
    xTaskCreatePinnedToCore(
      camera_and_ws_task, "CameraWS_Task", 10000, NULL, 1, NULL, 1);
}

void loop() {
  delay(10000); 
}

void webSocketEvent(WStype_t type, uint8_t * payload, size_t length) {
  switch(type) {
    case WStype_DISCONNECTED:
      Serial.println("[WSc] Disconnected!");
      break;
    case WStype_CONNECTED:
      Serial.printf("[WSc] Connected to server: %s\n", payload);
      webSocket.sendTXT("ESP32 Connected");
      break;
    case WStype_TEXT:
      Serial.printf("[WSc] Received text: %s\n", payload);
      break;
    case WStype_ERROR:
      Serial.printf("[WSc] Error: %s\n", payload);
      break;
    default:
      break;
  }
}

bool isValidJPEG(const uint8_t* buf, size_t len) {
  return len >= 2 && buf[0] == 0xFF && buf[1] == 0xD8;
}

void sendStatusUpdate() {
    // Read the temperature from the previous request.
    dallasTempC = sensors.getTempCByIndex(0);
    // Immediately request the next temperature reading.
    sensors.requestTemperatures();

    uint32_t freePsram = ESP.getFreePsram();
    uint32_t freeHeap = ESP.getFreeHeap();

    int rssi = WiFi.RSSI();  // Get current Wi-Fi signal strength in dBm
    
    String statusReport = "{";
    statusReport += "\"type\":\"status\",";
    statusReport += "\"freePsram\":" + String(freePsram) + ",";
    statusReport += "\"lastFrameSize\":" + String(lastFrameSize) + ",";
    statusReport += "\"lastFrameTimeMs\":" + String(lastFrameTime) + ",";
    statusReport += "\"freeHeap\":" + String(freeHeap) + ",";
    statusReport += "\"Min Time\":" + String(minCaptureTime) + ",";
    statusReport += "\"Max Time\":" + String(maxCaptureTime) + ",";

    #ifdef CAMERA_MODEL_AI_THINKER
      int tempC = (temprature_sens_read() - 32) / 1.8;
      statusReport += "\"esp32TempC\":" + String(tempC) + ",";
    #endif

    statusReport += "\"host_ident\":" + String(HOST_IDENT) + ",";
    statusReport += "\"dallasTempC\":" + String(dallasTempC) + ",";
    statusReport += "\"rssi\":" + String(rssi);
    statusReport += "}";
    
    String wrappedStatus = "JSON:" + statusReport;
    webSocket.sendTXT(statusReport);
}